module "sanctumos/kernel/network"

/*
 * SanctumNet – Einfacher Netzwerkstack
 *
 * Was? Dieses Modul stellt ein minimales Netzwerk-API bereit. Es
 * definiert die grundlegende Paketstruktur, Funktionen zum
 * Versenden und Empfangen von Paketen sowie eine einfache
 * Verbindungsverwaltung. Alle Netzwerkoperationen sind durch
 * Contracts geschützt, um Buffer Overflows zu verhindern und
 * unautorisierte Adressen zu blockieren.
 *
 * Warum? Selbst in Embedded‑Systemen ist oft eine Form von
 * Kommunikation notwendig. Eine sichere Networking-Schicht stellt
 * sicher, dass Datenpakete verifiziert und nur an erlaubte
 * Empfänger gesendet werden. Durch die klare Spezifikation in
 * Revelex lassen sich Sicherheitsanalysen und Audits durchführen,
 * bevor die Software im Feld eingesetzt wird.
 *
 * Wieso? Der Stack ist minimal gehalten: Es gibt keine
 * Routenverwaltung, keine komplexen Protokolle. Stattdessen
 * definieren wir ein einfaches Paketformat mit `src`, `dst` und
 * `payload`. Ein echtes Deployment könnte später auf UDP oder
 * TCP aufbauen. Die Sendefunktion überprüft Größe und Ziel; die
 * Empfangsfunktion ruft einen vom Benutzer registrierten
 * Callback auf. Alle Vorgänge werden mit `reflect` geloggt.
 */

struct Packet {
  src: Bytes,
  dst: Bytes,
  proto: String,
  payload: Bytes
}

var handlers: Map<String, fn(Packet)> = {}
var local_addr: Bytes = ""   // eigene Adresse

fn init() {
  // Netzwerk initialisieren – setze lokale Adresse (hier Demo)
  local_addr = "00:00:00:00:00:01"
  handlers = {}
  reflect { trace "net_init", { addr: local_addr } }
}

fn register_handler(proto:String, handler: fn(Packet)) {
  // Registriert einen Protokoll-Handler
  handlers[proto] = handler
}

fn send_packet(pkt: Packet) {
  ethos {
    require len(pkt.payload) <= 1024
    require pkt.dst != ""
  }
  reflect { trace "net_send", { src: pkt.src, dst: pkt.dst, proto: pkt.proto, size: len(pkt.payload) } }
  // In einer echten Implementation würden wir das Paket nun an eine
  // Hardware-Schnittstelle übergeben. Hier rufen wir den Handler
  // direkt auf, wenn der dst unserer Adresse entspricht.
  if pkt.dst == local_addr {
    receive_packet(pkt)
  }
}

fn receive_packet(pkt: Packet) {
  // Verarbeite eingehendes Paket
  if pkt.proto in handlers {
    handlers[pkt.proto](pkt)
  } else {
    reflect { trace "net_drop", { reason: "no handler", proto: pkt.proto } }
  }
}
