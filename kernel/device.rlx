module "sanctumos/kernel/device"

/*
 * Geräteschicht – Device Layer
 *
 * Was? Dieses Modul definiert abstrakte Geräteklassen und
 * implementiert grundlegende Geräte wie eine Konsole (für
 * Textausgabe) und ein Loopback-Netzwerkgerät. Jedes Gerät
 * besitzt eine eindeutige Kennung, kann geöffnet, gelesen und
 * geschrieben werden. Treiber können hinzugefügt werden, indem
 * neue Device-Implementationen erstellt werden. Alle Zugriffe
 * werden mit Contracts gesichert, um Buffer Overflows und
 * unautorisierte Zugriffe zu verhindern.
 *
 * Warum? Ein Betriebssystem braucht eine klare Abstraktion für
 * Hardware. Selbst wenn das Zielsystem nur virtuelle Hardware
 * bereitstellt, hilft ein Device Layer, unterschiedliche
 * Peripheriegeräte zu kapseln und ihren Zugriff zu standardisieren.
 *
 * Wieso? Der Device Manager verwaltet eine Liste registrierter
 * Geräte. Geräte können geöffnet werden, um Handles zu erhalten.
 * Die Konsole implementiert `write` durch Ausgabe in den
 * Reflect‑Log. Das Netzwerkgerät ruft das Netzwerkmodul an.
 */

import "sanctumos/kernel/network"

struct Device {
  id: Int,
  name: String,
  open: fn() => DeviceHandle,
  read: fn(DeviceHandle, Int) => Bytes,
  write: fn(DeviceHandle, Bytes) => Int
}

struct DeviceHandle {
  dev_id: Int,
  position: Int
}

var devices: Map<Int, Device> = {}
var next_dev_id: Int = 1

fn init() {
  devices = {}
  next_dev_id = 1
  // Register Console
  register_device("console", console_open, console_read, console_write)
  // Register Loopback-Netzwerkgerät
  register_device("loopnet", net_open, net_read, net_write)
  reflect { trace "device_init", { count: len(devices) } }
}

fn register_device(name:String, open_fn: fn() => DeviceHandle, read_fn: fn(DeviceHandle, Int) => Bytes, write_fn: fn(DeviceHandle, Bytes) => Int) {
  let dev_id = next_dev_id
  next_dev_id += 1
  let dev = Device(id=dev_id, name=name, open=open_fn, read=read_fn, write=write_fn)
  devices[dev_id] = dev
}

fn open_device(name:String) => Option<DeviceHandle> {
  for (id, dev) in devices {
    if dev.name == name {
      return dev.open()
    }
  }
  return None
}

// ---------- Konsole ----------

var console_buffer: String = ""

fn console_open() => DeviceHandle {
  return DeviceHandle(dev_id=1, position=len(console_buffer))
}

fn console_read(handle:DeviceHandle, count:Int) => Bytes {
  let remaining = console_buffer.slice(handle.position)
  return remaining.slice(0, count)
}

fn console_write(handle:DeviceHandle, data:Bytes) => Int {
  ethos { require len(data) > 0 }
  console_buffer = console_buffer + data
  // Schreibe in den Reflect-Log, um Ausgabe zu sehen
  reflect { trace "console_out", { data: data } }
  return len(data)
}

// ---------- Loopback-Netzwerkgerät ----------

fn net_open() => DeviceHandle {
  return DeviceHandle(dev_id=2, position=0)
}

fn net_read(handle:DeviceHandle, count:Int) => Bytes {
  // Für ein Loopback-Gerät gibt es keine Leseoperation
  return ""
}

fn net_write(handle:DeviceHandle, data:Bytes) => Int {
  // Daten als Netzwerkpaket interpretieren und senden
  // Wir nutzen den Packet-Typ aus dem Netzwerkmodul über die Namensqualifikation
  let pkt = network.Packet(src=network.local_addr, dst=network.local_addr, proto="loop", payload=data)
  network.send_packet(pkt)
  return len(data)
}
