module "sanctumos/kernel/ipc"

/*
 * Inter‑Process Communication (IPC)
 *
 * Was? Dieses Modul stellt einen einfachen Nachrichtenaustausch
 * zwischen Prozessen bereit. Eine „Channel“ abstrahiert eine
 * Kommunikationsverbindung. Prozesse können Nachrichten senden
 * und empfangen. Es handelt sich nicht um Shared Memory,
 * sondern um isolierte Queues, um Race Conditions zu vermeiden.
 *
 * Warum? Für ein echtes Betriebssystem reicht eine reine
 * Prozedurkommunikation nicht aus. Prozesse müssen Daten
 * austauschen können, ohne in den Speicher anderer Prozesse
 * einzugreifen. Klassische Systeme nutzen Pipes, Sockets oder
 * Message Queues. Revelex abstrahiert dies über Channel‑Objekte.
 *
 * Wieso? Wir implementieren Channels als Objekte mit einer
 * Nachrichtenwarteschlange. Senden fügt an die Warteschlange an,
 * Empfangen entfernt das erste Element. Contracts prüfen,
 * dass nur der Besitzer des Channels empfangen kann.
 */

import "sanctumos/kernel/security"

struct Channel {
  id: Int,
  owner: Int,
  queue: List<Bytes>
}

var channels: Map<Int, Channel> = {}
var next_chan_id: Int = 1

fn create_channel(owner:Int) => Channel {
  let id = next_chan_id
  next_chan_id += 1
  let ch = Channel(id=id, owner=owner, queue=[])
  channels[id] = ch
  reflect { trace "ipc_create", { chan: id, owner: owner } }
  return ch
}

fn send(chan:Channel, msg:Bytes) {
  ethos { require len(msg) <= 256 }
  let q = chan.queue
  chan.queue = q + [msg]
  channels[chan.id] = chan
  reflect { trace "ipc_send", { chan: chan.id, size: len(msg) } }
}

fn receive(chan:Channel) => Option<Bytes> {
  ethos { require security.has_capability(chan.owner, "ipc_receive") }
  let q = chan.queue
  if len(q) == 0 {
    return None
  }
  let msg = q[0]
  chan.queue = q[1:]
  channels[chan.id] = chan
  reflect { trace "ipc_recv", { chan: chan.id, size: len(msg) } }
  return Some(msg)
}
