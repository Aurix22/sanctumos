module "sanctumos/kernel/security"

/*
 * Sicherheitsmodul für SanctumOS
 *
 * Was? Dieses Modul verwaltet Berechtigungen, führt Signaturen aus
 * und verifiziert sie. Es bildet die Schnittstelle zwischen dem
 * Betriebssystem und dem Blxain‑Ledger: sicherheitsrelevante
 * Ereignisse werden als Transaktionen in das Ledger geschrieben.
 *
 * Warum? Sicherheit ist eine zentrale Anforderung für militärische
 * und wissenschaftliche Anwendungen. Prozesse dürfen nur auf
 * Ressourcen zugreifen, wenn sie die passenden Berechtigungen
 * besitzen. Signaturen sorgen dafür, dass Befehle eindeutig von
 * identifizierten Absendern stammen. Durch die Anbindung an
 * Blxain wird jeder Zugriff auditierbar.
 *
 * Wieso? Wir definieren eine einfache Capability-Liste pro Prozess.
 * Jedes Mal, wenn ein Prozess eine privilegierte Funktion nutzt,
 * prüfen wir seine Fähigkeiten. Signieren und Verifizieren nutzen
 * die kryptographischen Primitive aus dem Blxain‑Crypto‑Modul.
 */

import "blxain/crypto/hash"
import "blxain/crypto/sig"
import "sanctumos/kernel/tangle"

struct Capability {
  name: String,
  description: String
}

var process_caps: Map<Int, List<Capability>> = {}

fn init() {
  process_caps = {}
  reflect { trace "sec_init", { } }
}

fn grant_capability(pid:Int, cap:Capability) {
  let caps = process_caps.get(pid, [])
  process_caps[pid] = caps + [cap]
  reflect { trace "sec_grant", { pid: pid, cap: cap.name } }
}

fn has_capability(pid:Int, cap_name:String) => Bool {
  let caps = process_caps.get(pid, [])
  for c in caps {
    if c.name == cap_name {
      return true
    }
  }
  return false
}

fn sign_message(priv:Bytes, msg:Bytes) => Bytes {
  // Signiert eine Nachricht
  return sig.ed25519_sign(priv, msg)
}

fn verify_signature(pub:Bytes, msg:Bytes, signature:Bytes) => Bool {
  return sig.ed25519_verify(pub, msg, signature)
}

fn log_security_event(event:String, details:Any) {
  // Schreibt Sicherheitsereignisse ins Tangle
  tangle.append_event(event, details)
  reflect { trace event, details }
}
